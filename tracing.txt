**Prompt for Claude Code:**

```
Set up production-grade tracing with file logging + admin message output.

PART 1: File-based structured logging

Create agent_factory/core/trace_logger.py:

```python
import json
import logging
from datetime import datetime, timezone
from pathlib import Path
from logging.handlers import RotatingFileHandler
import uuid
import time

# Paths
LOG_DIR = Path("/root/Agent-Factory/logs")
TRACE_FILE = LOG_DIR / "traces.jsonl"
ERROR_FILE = LOG_DIR / "errors.jsonl"
METRICS_FILE = LOG_DIR / "metrics.jsonl"

LOG_DIR.mkdir(exist_ok=True)

# Rotating file handler (10MB max, keep 5 backups)
trace_handler = RotatingFileHandler(TRACE_FILE, maxBytes=10_000_000, backupCount=5)
error_handler = RotatingFileHandler(ERROR_FILE, maxBytes=10_000_000, backupCount=5)

class RequestTrace:
    """Context manager for tracing a full request lifecycle."""
    
    def __init__(self, message_type: str, user_id: str, username: str = None, content: str = ""):
        self.request_id = str(uuid.uuid4())[:8]
        self.message_type = message_type
        self.user_id = user_id
        self.username = username
        self.content = content[:500]
        self.start_time = time.time()
        self.events = []
        self.timings = {}
        
    def event(self, event_type: str, **data):
        """Log an event in this request's lifecycle."""
        elapsed_ms = int((time.time() - self.start_time) * 1000)
        entry = {
            "request_id": self.request_id,
            "elapsed_ms": elapsed_ms,
            "event": event_type,
            **data
        }
        self.events.append(entry)
        self._write_log(entry)
        
    def timing(self, step: str, ms: int):
        """Record timing for a step."""
        self.timings[step] = ms
        
    def error(self, error_type: str, message: str, location: str):
        """Log an error."""
        entry = {
            "request_id": self.request_id,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "error_type": error_type,
            "message": message,
            "location": location,
            "user_id": self.user_id,
            "content": self.content
        }
        self._write_error(entry)
        self.events.append({"event": "ERROR", **entry})
        
    def _write_log(self, entry: dict):
        entry["timestamp"] = datetime.now(timezone.utc).isoformat()
        with open(TRACE_FILE, "a") as f:
            f.write(json.dumps(entry) + "\n")
            
    def _write_error(self, entry: dict):
        with open(ERROR_FILE, "a") as f:
            f.write(json.dumps(entry) + "\n")
    
    def summary(self) -> dict:
        """Return summary for admin message."""
        total_ms = int((time.time() - self.start_time) * 1000)
        return {
            "request_id": self.request_id,
            "message_type": self.message_type,
            "user_id": self.user_id,
            "total_ms": total_ms,
            "timings": self.timings,
            "events": [e["event"] for e in self.events]
        }
    
    def format_admin_message(self, route: str, confidence: float, kb_atoms: int, 
                              llm_model: str = None, ocr_result: dict = None,
                              kb_coverage: str = "none", error: str = None) -> str:
        """Format the second message for admin."""
        total_ms = int((time.time() - self.start_time) * 1000)
        
        lines = ["```"]
        lines.append(f"TRACE [{self.request_id}]")
        lines.append("‚ïê" * 30)
        
        # Input section
        if self.message_type == "photo" and ocr_result:
            lines.append("üì∑ OCR RESULT")
            lines.append(f"  Manufacturer: {ocr_result.get('manufacturer', 'N/A')}")
            lines.append(f"  Model: {ocr_result.get('model', 'N/A')}")
            lines.append(f"  Fault Code: {ocr_result.get('fault_code', 'N/A')}")
            lines.append("")
        
        # Routing section
        lines.append("üîÄ ROUTING")
        lines.append(f"  Route: {route}")
        lines.append(f"  Confidence: {confidence:.0%}")
        lines.append(f"  KB Coverage: {kb_coverage}")
        lines.append(f"  KB Atoms: {kb_atoms}")
        lines.append("")
        
        # LLM section
        if llm_model:
            lines.append("ü§ñ LLM")
            lines.append(f"  Model: {llm_model}")
            lines.append(f"  Cost: ${self.timings.get('llm_cost', 0):.4f}")
            lines.append("")
        
        # Timing section
        lines.append("‚è±Ô∏è TIMING")
        for step, ms in self.timings.items():
            if step != "llm_cost":
                lines.append(f"  {step}: {ms}ms")
        lines.append(f"  TOTAL: {total_ms}ms")
        lines.append("")
        
        # Error section
        if error:
            lines.append("‚ùå ERROR")
            lines.append(f"  {error}")
            lines.append("")
        
        # Footer
        lines.append("‚ïê" * 30)
        lines.append(f"User: {self.user_id}")
        lines.append(f"Time: {datetime.now(timezone.utc).strftime('%H:%M:%S UTC')}")
        lines.append("```")
        
        return "\n".join(lines)
```

PART 2: Integration into orchestrator_bot.py

```python
from agent_factory.core.trace_logger import RequestTrace

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    # Start trace
    trace = RequestTrace(
        message_type="text",
        user_id=str(update.effective_user.id),
        username=update.effective_user.username,
        content=update.message.text or ""
    )
    trace.event("INPUT_RECEIVED")
    
    try:
        # KB Search
        kb_start = time.time()
        # ... kb search logic ...
        trace.timing("kb_search", int((time.time() - kb_start) * 1000))
        trace.event("KB_SEARCH", atoms_found=atoms_found, top_score=top_score)
        
        # Route Decision
        trace.event("ROUTE_DECISION", route=route, confidence=confidence, reason=reason)
        
        # LLM Call (if needed)
        llm_start = time.time()
        # ... llm call ...
        trace.timing("llm_call", int((time.time() - llm_start) * 1000))
        trace.timing("llm_cost", cost)
        trace.event("LLM_CALL", model=model, tokens=tokens)
        
        # Send response to user (Message 1)
        await update.message.reply_text(response_text, parse_mode="Markdown")
        trace.event("RESPONSE_SENT", length=len(response_text))
        
        # Send trace to admin (Message 2)
        admin_message = trace.format_admin_message(
            route=route,
            confidence=confidence,
            kb_atoms=atoms_found,
            llm_model=model_used,
            kb_coverage=coverage_level
        )
        await context.bot.send_message(
            chat_id=ADMIN_CHAT_ID,
            text=admin_message,
            parse_mode="Markdown"
        )
        
    except Exception as e:
        trace.error(type(e).__name__, str(e), "handle_message")
        # Still send error trace to admin
        admin_message = trace.format_admin_message(
            route="ERROR",
            confidence=0,
            kb_atoms=0,
            error=str(e)
        )
        await context.bot.send_message(chat_id=ADMIN_CHAT_ID, text=admin_message)
        raise

async def handle_photo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    trace = RequestTrace(
        message_type="photo",
        user_id=str(update.effective_user.id),
        username=update.effective_user.username,
        content=f"photo:{update.message.photo[-1].file_id[:20]}"
    )
    trace.event("PHOTO_RECEIVED")
    
    # ... OCR logic ...
    trace.timing("ocr", ocr_ms)
    trace.event("OCR_COMPLETE", manufacturer=mfr, model=model)
    
    # ... rest of flow, same pattern ...
    
    # Send trace with OCR result
    admin_message = trace.format_admin_message(
        route=route,
        confidence=confidence,
        kb_atoms=atoms_found,
        llm_model=model_used,
        ocr_result={"manufacturer": mfr, "model": model, "fault_code": fault}
    )
```

PART 3: Log viewer scripts

Create scripts/trace_viewer.py:
```python
"""
Usage:
  python trace_viewer.py                    # Last 20 requests
  python trace_viewer.py -n 50              # Last 50 requests  
  python trace_viewer.py -r abc123          # Specific request ID
  python trace_viewer.py -e                 # Errors only
  python trace_viewer.py --today            # Today's requests
  python trace_viewer.py --slow 1000        # Requests over 1000ms
"""
import json
import argparse
from pathlib import Path
from datetime import datetime, date

TRACE_FILE = Path("/root/Agent-Factory/logs/traces.jsonl")
ERROR_FILE = Path("/root/Agent-Factory/logs/errors.jsonl")

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-n", type=int, default=20, help="Number of entries")
    parser.add_argument("-r", type=str, help="Request ID filter")
    parser.add_argument("-e", action="store_true", help="Errors only")
    parser.add_argument("--today", action="store_true", help="Today only")
    parser.add_argument("--slow", type=int, help="Requests slower than N ms")
    args = parser.parse_args()
    
    source = ERROR_FILE if args.e else TRACE_FILE
    lines = source.read_text().strip().split("\n") if source.exists() else []
    
    for line in lines[-args.n:]:
        entry = json.loads(line)
        
        if args.r and entry.get("request_id") != args.r:
            continue
        if args.today and not entry.get("timestamp", "").startswith(str(date.today())):
            continue
        if args.slow and entry.get("elapsed_ms", 0) < args.slow:
            continue
            
        ts = entry.get("timestamp", "")[:19]
        req_id = entry.get("request_id", "--------")
        event = entry.get("event", entry.get("error_type", "???"))
        
        # Format output
        details = {k: v for k, v in entry.items() if k not in ["timestamp", "request_id", "event"]}
        print(f"{ts} | {req_id} | {event:20} | {json.dumps(details)}")

if __name__ == "__main__":
    main()
```

Create scripts/trace_stats.py:
```python
"""Daily stats summary."""
import json
from pathlib import Path
from collections import Counter
from datetime import date

TRACE_FILE = Path("/root/Agent-Factory/logs/traces.jsonl")

lines = TRACE_FILE.read_text().strip().split("\n") if TRACE_FILE.exists() else []
today = str(date.today())

requests = Counter()
routes = Counter()
errors = 0
total_latency = []

for line in lines:
    entry = json.loads(line)
    if not entry.get("timestamp", "").startswith(today):
        continue
    
    event = entry.get("event", "")
    if event == "INPUT_RECEIVED":
        requests[entry.get("message_type", "unknown")] += 1
    elif event == "ROUTE_DECISION":
        routes[entry.get("route", "unknown")] += 1
    elif event == "ERROR":
        errors += 1
    elif event == "RESPONSE_SENT":
        if "elapsed_ms" in entry:
            total_latency.append(entry["elapsed_ms"])

print(f"=== Stats for {today} ===")
print(f"Total requests: {sum(requests.values())}")
print(f"  Text: {requests.get('text', 0)}")
print(f"  Photo: {requests.get('photo', 0)}")
print(f"  Command: {requests.get('command', 0)}")
print(f"\nRoutes:")
for route, count in routes.most_common():
    print(f"  {route}: {count}")
print(f"\nErrors: {errors}")
if total_latency:
    print(f"\nLatency:")
    print(f"  Avg: {sum(total_latency)//len(total_latency)}ms")
    print(f"  Max: {max(total_latency)}ms")
    print(f"  Min: {min(total_latency)}ms")
```

PART 4: Deploy and test

1. Deploy changes to VPS
2. Send a test message and photo
3. Show me the admin trace message you receive
4. Run: ssh vps "python /root/Agent-Factory/scripts/trace_viewer.py -n 10"

The admin message should look like:
```
TRACE [a1b2c3d4]
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
üì∑ OCR RESULT
  Manufacturer: Fuji Electric
  Model: FRN0040C2S-4U
  Fault Code: N/A

üîÄ ROUTING
  Route: C_research
  Confidence: 54%
  KB Coverage: none
  KB Atoms: 0

ü§ñ LLM
  Model: groq/llama-3.1-70b
  Cost: $0.0000

‚è±Ô∏è TIMING
  ocr: 1245ms
  kb_search: 43ms
  llm_call: 892ms
  TOTAL: 2203ms

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
User: 8445149012
Time: 18:45:23 UTC
```
```

This gives you:
- **File logs** (JSONL) - for Claude to analyze patterns
- **Admin messages** - real-time visibility in Telegram
- **Viewer scripts** - quick debugging from CLI
- **Stats script** - daily usage summary
- **Error isolation** - separate error log for quick triage
- **Log rotation** - won't fill your disk